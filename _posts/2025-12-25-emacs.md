---
title: Emacs - O meu novo computador
---

O Emacs é famoso por ser um programa que faz de *tudo*. E isso não é
exagero (antes fosse!). Com ele você consegue fazer desde a tarefa mais
básica que é editar texto, a planilhas, gestão de projetos, leitura de
feeds RSS, comunicação via IRC, XMPP ou E-mail...

Enfim, **muita** coisa.

Óbviamente eu não faço tudo isso que listei acima, mas faço sim algumas
coisas com ele e gostaria de escrever sobre. Bom, vamos começar!

# Minha atual configuração
Depois de um tempo em hiato, eu voltei a desenvolver a minha
configuração do Emacs. Agora ela além de estar mais robusta, configurei
até mesmo o cliente de e-mail ["Rmail"](https://www.gnu.org/software/emacs/manual/html_node/emacs/Rmail.html) (o "cliente de e-mail padrão do Emacs") e o [Erc](https://www.gnu.org/software/emacs/erc.html) (o cliente IRC pré-instalado do Emacs).

Além disso, usei um snippet do pessoal do [System Crafters](https://systemcrafters.net) para
conseguir usar com mais facilidade a funcionalidade de leitura de
arquivos `gpg`, o nome da função é meio estranho, mas basicamente, eu só
preciso chamar ela e dar como um argumento uma chave presente no
arquivo `.authinfo` e ela me retornará a senha correspondente à essa
chave.

Como por exemplo:

```elisp
(efs/lookup-password :machine irc.libera.chat)
```

> [A função em si é essa aqui](https://systemcrafters.net/emacs-tips/using-encrypted-passwords/):
>
> ```elisp
> (defun efs/lookup-password (&rest keys)
>   (let ((result (apply #'auth-source-search keys)))
>     (if result
>         (funcall (plist-get (car result) :secret))
>       nil)))
> ```
>

Eu também dei uma repaginada no alinhamento das coisas, afinal, não
basta funcionar, tem que ser bonito de se ver, e a Elisp é uma
linguagem ótima para fazer esse tipo de coisa! Porque ela:

- Não se importa com a quantidade de espaços que existe entre uma
  função e um parâmetro;
- Tem uma sintáxe bem simples de se ler (às vezes).

Sendo assim, eu consigo fazer esse tipo de coisa aqui:

```elisp
(icomplete-mode		               	t)
(ido-mode		               	t)
(ido-everywhere		               	t)
(which-key-mode		               	t)
(delete-selection-mode	               	t)
(global-visual-line-mode               	t)
(global-auto-revert-mode               	t)
(global-prettify-symbols-mode          	t)
(global-hl-line-mode	               	t)
(global-completion-preview-mode        	t)
(global-display-line-numbers-mode       t)
(fido-vertical-mode			t)
```

> "Perfeitamente equilibrado, como tudo deve ser."

![](https://i.redd.it/qpbqimfqx4p71.jpg)

# Organização financeira
O [`org-mode`](https://orgmode.org) tem a funcionalidade de gerar planilhas, com
fórmulas e tudo!

Por exemplo, digamos que eu esteja gerendo uma planilha contendo os
meus gastos mensais com planos de assinatura/contas recorrentes. Eu
poderia fazer isso aqui:

```org
| Nome        | Dia de cobrança | Valor (R$) |
|-------------+-----------------+------------|
| Netflix     |              22 |      20.90 |
| Crunchyroll |              11 |      14.99 |
|-------------+-----------------+------------|
| Total       |                 |   35.89 R$ |
#+TBLFM: @>$3=string("R$")vsum(@I$3..@II$3)
```

É, a sintáxe não é lá aquelas coisas... mas é funcional. Para coisas
simples ela é relativamente intuitiva (+/- né). O maneiro mesmo é
escrever essas tabelas, por quê? Porque o Emacs formata
automagicamente elas! É só começar uma tabela com `| nome` e apertar
`tab`!

Além disso, também existe a tecla de atalho =Ctrl c }= que exibe alguns
marcadores na tabela para poder facilitar o processo de escrever as
fórmulas.

Ficando +/- assim:
```
   1| Nome        | Dia de cobrança | Valor (R$) |
I*1 |-------------+-----------------+------------|
   2| Netflix     |              22 | 20.90      |
   3| Crunchyroll |              11 | 14.99      |
I*2 |-------------+-----------------+------------|
   4| Total       |                 | 35.89 R$   |
   5| Média       |                 | 17.945 R$  |
#+TBLFM: @4$3=string("R$")vsum(@I$3..@II$3)::@5$3=string("R$")vmean(@I$3..@II$3)
```

Como eu estou tentando diminuir o meu uso no celular, isso pode ser
o tipo de coisa que pode me ajudar. Dessa forma eu vou ter um jeito
de gerenciar as minhas finanças sem depender de aplicativos no meu
celular. Até porque eu posso criar _deadlines_ no `org-mode` e
visualizar meus afazeres usando a agenda integrada dele!

> Devo que admitir que não sei ainda como se usa o `org-agenda`, mas pelo o que
> eu li no [site oficial](https://orgmode.org/features.html#agendas) parece ser muito bacana!

# Workflow de programação
O Emacs é primariamente um editor de código (por mais incrível que pareça).
Sendo assim, ele possui *várias* funções e configurações para deixar a
usabilidade na hora de programar melhor.

Uma das coisas mais maneiras do Emacs é a Elisp, a linguagem que ele é
configurado, interpreta e é em boa parte [escrito nela também](/blog/posts/2025/06/30/elisp). A parte de "interpretar" é que é a mais interessante, porquê isso permite que você teste
um "plugin" sem a necessidade de instalar ele! Você só precisa criar um buffer
ou abrir o "_scratch buffer_" e apertar `Ctrl c` `Ctrl e`. Isso vai fazer o Emacs
interpretar o buffer inteiro, e dessa forma, você pode testar o "plugin" à
vontade enquanto o Emacs estiver aberto!

Então você pode, por exemplo, testar um "plugin" que dá _syntax highlighting_
(colorização de código) para alguma linguagem de programação que não é
suportada por padrão pelo Emacs, como a [Hare](https://harelang.org), por exemplo.

Também tem o `compile-mode`... Meu Deus, por que isso não é um padrão de
indústria?

Basicamente, o `compile-mode` serve para executar um comando especificado por
você no diretório em que você estava e, caso aconteça erros, ele cria "links"
com base nas linhas/colunas especificadas pela mensagem de erro.

Por exemplo...

```rust
// Eu não incluí o módulo "fmt", necessário para usar a função "println"

export fn main() void = {
	println("Olá, mundo!")!;
};
```

```example
teste.ha:2:16: error: Unknown object 'println'

2 |		println("Olá, mundo!")!;
  |	               ^


harec for /tmp/teste.ha exited with status 4
```

A parte escrita com `teste.ha:2:16:` viraria um link, onde se eu clicar, o Emacs
abriria o arquivo onde o erro ocorreu e deixaria o ponteiro do editor na linha
e na coluna especificada pelo erro.

Depois de corrigir o erro, eu só preciso apertar uma tecla de atalho para que
o comando usado para compilar o programa seja re-executado. Sem a necessidade
de ir até onde o arquivo do programa está!

Particularmente isso é bem útil para mim, já que eu sou bem iniciante no mundo
de programação, e isso é uma mão na roda na hora de escrever algo.

> Principalmente na hora de desenvolver as [minhas bindings](https://codeberg.org/tukain/raylib.ha) para a [Raylib](https://github.com/raysan5/raylib).
>
> Com uma sintáxe dessas aqui a última coisa que eu quero é ter que fazer todo
> esse processo na mão:
>
> ```rust
> @symbol("TakeScreenshot") fn TakeScreenshot(filename: *c::char) void;
> export fn take_screenshot(filename: str) void = TakeScreenshot(c::fromstr(filename: str)!);
> ```

# Conclusão

Enfim, acho que já deu para entender um pouco sobre algumas das coisas que eu
faço (e coisas que dá para fazer) com o Emacs. Faz um bom tempo que eu não
escrevo um post tão longo, já estava com saudades!

Até o próximo post!
