#+TITLE: Emacs - O meu novo computador
#+DATE: <2025-12-25 qui>

O Emacs é famoso por ser um programa que faz de *tudo*. E isso não é
exagero (antes fosse!). Com ele você consegue fazer desde a tarefa mais
básica que é editar texto, a planilhas, gestão de projetos, leitura de
feeds RSS, comunicação via IRC, XMPP ou E-mail...

Enfim, **muita** coisa.

Óbviamente eu não faço tudo isso que listei acima, mas faço sim algumas
coisas com ele e gostaria de escrever sobre. Bom, vamos começar!

* Minha atual configuração
Depois de um tempo em hiato, eu voltei a desenvolver a minha
configuração do Emacs. Agora ela além de estar mais robusta, configurei
até mesmo o cliente de e-mail [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Rmail.html]["Rmail"]] (o "cliente de e-mail padrão do
Emacs") e o [[https://www.gnu.org/software/emacs/erc.html][Erc]] (o cliente IRC pré-instalado do Emacs).

Além disso, usei um snippet do pessoal do [[https://systemcrafters.net][System Crafters]] para
conseguir usar com mais facilidade a funcionalidade de leitura de
arquivos ~gpg~, o nome da função é meio estranho, mas basicamente, eu só
preciso chamar ela e dar como um argumento uma chave presente no
arquivo ~.authinfo~ e ela me retornará a senha correspondente à essa
chave.

Como por exemplo:

#+begin_src emacs-lisp
(efs/lookup-password :machine irc.libera.chat)
#+end_src
#+begin_quote
[[https://systemcrafters.net/emacs-tips/using-encrypted-passwords/#accessing-passwords-outside-of-emacs][A função em si é essa aqui]]:

#+begin_src elisp
(defun efs/lookup-password (&rest keys)
  (let ((result (apply #'auth-source-search keys)))
    (if result
        (funcall (plist-get (car result) :secret))
      nil)))
#+end_src
#+end_quote

Eu também dei uma repaginada no alinhamento das coisas, afinal, não
basta funcionar, tem que ser bonito de se ver, e a Elisp é uma
linguagem ótima para fazer esse tipo de coisa! Porque ela:

- Não se importa com a quantidade de espaços que existe entre uma
  função e um parâmetro;
- Tem uma sintáxe bem simples de se ler (às vezes).

Sendo assim, eu consigo fazer esse tipo de coisa aqui:

#+begin_src elisp
(icomplete-mode		               	t)
(ido-mode		               	t)
(ido-everywhere		               	t)
(which-key-mode		               	t)
(delete-selection-mode	               	t)
(global-visual-line-mode               	t)
(global-auto-revert-mode               	t)
(global-prettify-symbols-mode          	t)
(global-hl-line-mode	               	t)
(global-completion-preview-mode        	t)
(global-display-line-numbers-mode       t)
(fido-vertical-mode			t)
#+end_src

#+begin_quote
"Perfeitamente equilibrado, como tudo deve ser."
#+end_quote

[[https://i.redd.it/qpbqimfqx4p71.jpg]]

* Meu novo site
Também reescrevi meu site usando o ~ox-publish~, a
funcionalidade de publicação de documentos nativa do Emacs! Quando
configurado de uma certa forma, ele não fica muito diferente de um [[https://jekyllrb.com][SSG]]
ou [[https://codeberg.org/tukain/blog.sh][algo do gênero]].

Dentre vários facilitadores dados pelo [[https://orgmode.org/][org-mode]], acho que a que eu mais
gosto é o /syntax highlighting/. Ele usa as cores do tema que você está
usando no Emacs! Além disso, você também consegue executar os blocos
de códigos presentes no documento e exibir o resultado desses blocos!

#+begin_src elisp :eval yes :exports both
(message "Maneiro, né?")
#+end_src

#+RESULTS:
: Maneiro, né?

Não tenho ainda muitas ideias do que eu posso fazer com essa
coisinha, mas pode ser que seja útil para demonstrar algo que aprendi
a fazer na [[https://harelang.org][Hare]] (desde que o output seja em texto, claro).

O que eu sei é que o desenvolvimento do site passa a ser algo
centralizado no Emacs. Algo que tem seus lados positivos, mas também
tem seus negativos. O que eu posso fazer é tirar proveito dos
~git submodules~ para conseguir gerenciar um repositório com o
"código-fonte" do site e o site "compilado" de forma facilitada
(o que eu [[https://codeberg.org/tukain/site][já]] [[https://codeberg.org/tukain/pages][fazia]] na realidade).

Ah, mais uma coisa que eu lembrei agora: cada página desse site
funciona de forma "independente" das outras. Basicamente, todas as
páginas já incluem toda a estilização necessária para ter a aparência
do site (todas elas incluem uma /tag/ ~<style>~ com o CSS do site :P).

Além disso, eu também consigo integrar a paleta de cor do tema que eu estou
usando no Emacs e aplicar ela no CSS do site!

Ou seja, as cores que o site tem, são as mesmas que a do meu Emacs, sem que
eu precise definir elas manualmente!

#+begin_src emacs-lisp
(setq org-html-head-extra
      (concat
       "<head><link rel='icon' href='/assets/fav.png'></head>"
       "<style>"
       (with-temp-buffer (insert-file-contents "src/assets/styles.css") (buffer-string))
       ":root {"
           "--bg-1:"    (face-attribute 'default :background)			";"
           "--bg-0:"    (face-attribute 'hl-line :background nil 'default)	";"
           "--fg:"	(face-attribute 'default :foreground)			";"
           "--ac:"	(face-attribute 'cursor  :background nil 'default)	";"
       "}"
       "</style>"))
#+end_src

* Organização financeira
O ~org-mode~ também tem a funcionalidade de gerir planilhas, com
fórmulas e tudo!

Por exemplo, digamos que eu esteja gerendo uma planilha contendo os
meus gastos mensais com planos de assinatura/contas recorrentes. Eu
poderia fazer isso aqui:

#+begin_src org
| Nome        | Dia de cobrança | Valor (R$) |
|-------------+-----------------+------------|
| Netflix     |              22 |      20.90 |
| Crunchyroll |              11 |      14.99 |
|-------------+-----------------+------------|
| Total       |                 |   35.89 R$ |
#+TBLFM: @>$3=string("R$")vsum(@I$3..@II$3)
#+end_src

É, a sintáxe não é lá aquelas coisas... mas é funcional. Para coisas
simples ela é relativamente intuitiva (+/- né). O maneiro mesmo é
escrever essas tabelas, por quê? Porque o Emacs formata
automagicamente elas! É só começar uma tabela com ~| nome~ e apertar
=tab=!

Além disso, também existe a tecla de atalho =Ctrl c }= que exibe alguns
marcadores na tabela para poder facilitar o processo de escrever as
fórmulas.

Ficando +/- assim:
#+begin_src org
   1| Nome        | Dia de cobrança | Valor (R$) |
I*1 |-------------+-----------------+------------|
   2| Netflix     |              22 | 20.90      |
   3| Crunchyroll |              11 | 14.99      |
I*2 |-------------+-----------------+------------|
   4| Total       |                 | 35.89 R$   |
   5| Média       |                 | 17.945 R$  |
#+TBLFM: @4$3=string("R$")vsum(@I$3..@II$3)::@5$3=string("R$")vmean(@I$3..@II$3)
#+end_src

Como eu estou tentando diminuir o meu uso no celular, isso pode ser
o tipo de coisa que pode me ajudar. Dessa forma eu vou ter um jeito
de gerenciar as minhas finanças sem depender de aplicativos no meu
celular. Até porque eu posso criar /deadlines/ no ~org-mode~ e
visualizar meus afazeres usando a agenda integrada dele!

#+begin_quote
Devo que admitir que não sei ainda como se usa o ~org-agenda~, mas pelo o que
eu li no [[https://orgmode.org/features.html#agendas][site oficial]] parece ser muito bacana!
#+end_quote

* Workflow de programação
O Emacs é primariamente um editor de código (por mais incrível que pareça).
Sendo assim, ele possui *várias* funções e configurações para deixar a
usabilidade na hora de programar melhor.

Uma das coisas mais maneiras do Emacs é a Elisp, a linguagem que ele é
configurado, interpreta e é em boa parte [[file:2025-06-30.org][escrito nela também]]. A parte de
"interpretar" é que é a mais interessante, porquê isso permite que você teste
um "plugin" sem a necessidade de instalar ele! Você só precisa criar um buffer
ou abrir o "/scratch buffer/" e apertar =Ctrl c= =Ctrl e=. Isso vai fazer o Emacs
interpretar o buffer inteiro, e dessa forma, você pode testar o "plugin" à
vontade enquanto o Emacs estiver aberto!

Então você pode, por exemplo, testar um "plugin" que dá /syntax highlighting/
(colorização de código) para alguma linguagem de programação que não é
suportada por padrão pelo Emacs, como a [[https://harelang.org][Hare]], por exemplo.

Também tem o ~compile-mode~... Meu Deus, por que isso não é um padrão de
indústria?

Basicamente, o ~compile-mode~ serve para executar um comando especificado por
você no diretório em que você estava e, caso aconteça erros, ele cria "links"
com base nas linhas/colunas especificadas pela mensagem de erro.

Por exemplo...

#+begin_src simphare
// Eu não incluí o módulo "fmt", necessário para usar a função "println"

export fn main() void = {
	println("Olá, mundo!")!;
};
#+end_src

#+BEGIN_EXAMPLE
teste.ha:2:16: error: Unknown object 'println'

2 |		println("Olá, mundo!")!;
  |	               ^


harec for /tmp/teste.ha exited with status 4
#+END_EXAMPLE

A parte escrita com =teste.ha:2:16:= viraria um link, onde se eu clicar, o Emacs
abriria o arquivo onde o erro ocorreu e deixaria o ponteiro do editor na linha
e na coluna especificada pelo erro.

Depois de corrigir o erro, eu só preciso apertar uma tecla de atalho para que
o comando usado para compilar o programa seja re-executado. Sem a necessidade
de ir até onde o arquivo do programa está!

Particularmente isso é bem útil para mim, já que eu sou bem iniciante no mundo
de programação, e isso é uma mão na roda na hora de escrever algo.

#+begin_quote
Principalmente na hora de desenvolver as [[https://codeberg.org/tukain/raylib.ha][minhas bindings]] para a [[https://github.com/raysan5/raylib][Raylib]].

Com uma sintáxe dessas aqui a última coisa que eu quero é ter que fazer todo
esse processo na mão:

#+begin_src simphare
@symbol("TakeScreenshot") fn TakeScreenshot(filename: *c::char) void;
export fn take_screenshot(filename: str) void = TakeScreenshot(c::fromstr(filename: str)!);
#+end_src
#+end_quote

* Conclusão

Enfim, acho que já deu para entender um pouco sobre algumas das coisas que eu
faço (e coisas que dá para fazer) com o Emacs. Faz um bom tempo que eu não
escrevo um post tão longo, já estava com saudades!

Até o próximo post!
